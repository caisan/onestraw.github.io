---
layout: single
author_profile: true
comments: true
title: Linux内核加载到内存的过程
categories: [Linux]
tags: [Linux]
---
今天开始学习Linux内核，睡前梳理一下Linux内核被加载到内存的过程，内核版本linux0.11

1. CPU只能执行内存的代码（CS:IP指向的内存位置），而在按下电源键启动时，内存（RAM）是空的，如何运行程序呢？软件不行，靠硬件。

一旦加电，CS的值立即置为0xffff, IP的值置为0×0000, BIOS程序将自己加载到内存中，其入口地址为CS:IP,即0xffff0。这一步完全靠硬件实现。

2. 这时，CPU可以执行代码了，执行的是BIOS程序，因为CS:IP指向的是BIOS程序在内存的位置。

（ps: BIOS程序不属于内核，我们不去分析它）

3. BIOS程序在内存区0×00000处开辟1KB的空间用于构建中断向量表，紧挨着中断向量表后面用256B的内存作为BIOS数据区。在之后大约56KB的位置加载了8KB左右的中断服务程序。

（ps: 中断向量表有256个中断向量，每个中断向量4字节，前两个字节是CS，后两个字节是IP. CPU根据中断类型码，在中断向量表中查找对应的表项&lt;中断向量表类似一个数组，中断类型码类似于数组下标&gt;，从而得到中断服务程序的入口地 址，这样CPU就可以执行中断服务程序。中断服务程序属于BIOS程序，它从BIOS加载进内存，不属于内核）

4. CPU 执行int 0×19中断（略去了很多BIOS代码功能），转到相应的中断服务程序入口，该中断服务程序的功能是：找到软盘（比较古老，可以理解为系统盘），并加载第 一扇区至0x07c00处，该扇区存储着linux 0.11的引导程序，对应着源文件linux0.11/boot/bootsect.s。

5. 下面就开始执行内核程序了，首先是bootsect.s，这是汇编程序，它首先将自己复制到0×90000处，这是因为内核要重新布局内存空间了。

6. bootsect.s中有一个int 0×13 中断，将软盘第2扇区至第5扇区的内容（对应/boot/setup.s）加载到内存的0×90200处。bootsect.s和setup.s在内存是紧挨着的。

7. 现在bootsect.s还没有执行完， 还有一块代码要加载进来，还是调用 int 0×13中断 ，将从第6扇区开始的约240个扇区的system模块加载到内存0×10000位置。bootsect.s执行完成，它的任务也全部完成。

8. 执行setup.s代码，通过中断获取硬盘参数表1和2，有510字节，覆盖bootsect.s内存（512字节）。

内核加载工作完成！
